{"content":"<p>state 的改变必须经过 <code>store.dispatch</code> 方法，<code>dispatch</code> 方法会返回接收的 <code>action</code>。</p>\n<a id=\"more\"></a>\n<h2 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer\"></a>reducer</h2><h3 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h3><pre><code>@param {Object} reducers An object whose values correspond to different reducer functions that need to be combined into one.\n@returns {Function} A reducer function that invokes every reducer inside the passed object, and builds a state object with the same shape.\n</code></pre><p>接受多个 <code>reducer</code> 组成的 <code>object</code>，返回一个最终的 <code>reducer</code> 作为 <code>rootRecuer</code>。该 <code>reducer</code> 会将接收到的 <code>action</code> 分发给每一个接收到的 <code>reducer</code> 中。</p>\n<p>核心代码：</p>\n<pre><code>let hasChanged = false\nconst nextState = {}\nfor (let i = 0; i &lt; finalReducerKeys.length; i++) {\n  const key = finalReducerKeys[i]\n  const reducer = finalReducers[key]\n  const previousStateForKey = state[key]\n  const nextStateForKey = reducer(previousStateForKey, action)\n  if (typeof nextStateForKey === &#39;undefined&#39;) {\n    const errorMessage = getUndefinedStateErrorMessage(key, action)\n    throw new Error(errorMessage)\n  }\n  nextState[key] = nextStateForKey\n  hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n}\nreturn hasChanged ? nextState : state\n</code></pre><p>因为最后返回的也是一个 <code>reducer</code> ，所以 <code>combineReducers</code> 方法可以嵌套使用。</p>\n<p>接收的参数对象的 key，对应 store state 的 key。<br>例如 <code>combineReducers({ part1: reducer1, part12: reducer2 })</code>，对应的 store state 形如 <code>{ part1: state1, part2: state2 }</code></p>\n<h2 id=\"middleware\"><a href=\"#middleware\" class=\"headerlink\" title=\"middleware\"></a>middleware</h2><p>每个 middleware 会接收两个方法 <code>dispatch</code> and <code>getState</code> 作为 named arguments。传递方法来获得 store state 来保证每个 middleware 或得的 state 为最新的。</p>\n<p>形如 <code>({ dispatch, getState }) =&gt; next =&gt; action =&gt; {}</code></p>\n<p>以 <code>redux-thunk</code> 为例：</p>\n<pre><code>function createThunkMiddleware(extraArgument) {\n  return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {\n    if (typeof action === &#39;function&#39;) {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return next(action);\n  };\n}\n\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n</code></pre><h3 id=\"applyMiddleware\"><a href=\"#applyMiddleware\" class=\"headerlink\" title=\"applyMiddleware\"></a>applyMiddleware</h3><p>applyMiddleware 的作用其实便是对 <code>store.dispatch</code> 的处理</p>\n<pre><code>@param {...Function} middlewares The middleware chain to be applied.\n@returns {Function} A store enhancer applying the middleware.\n</code></pre><p>首先会获取加入 middleware 前的 <code>dispatch</code> 方法（最后返回的 <code>dispatch</code> 不一样，作为 fallback dispatch），并作为每个 <code>middleware</code> 的参数。</p>\n<pre><code>export default function applyMiddleware(...middlewares) {\n  return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; {\n    // enhancer will always be undefined\n    const store = createStore(reducer, preloadedState, enhancer)\n    // as middleware&#39;s named arguments and fallback dispatch\n    let dispatch = store.dispatch\n    let chain = []\n\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action) =&gt; dispatch(action)\n    }\n    // chain all middlewares together, and now every middleware now expects a next function and an action (thunk).\n    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))\n    dispatch = compose(...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n</code></pre><p><code>applyMiddlewares</code> 这样实现的一个特性是，每一个 middleware 必须调用它的 <code>next</code> 方法，否则 chained middleware 会在此断掉。<code>next</code> 方法的参数即为下一个 middleware 的 <code>action</code></p>\n<h2 id=\"有趣的设计\"><a href=\"#有趣的设计\" class=\"headerlink\" title=\"有趣的设计\"></a>有趣的设计</h2><p>在 <code>createStore</code> 方法中</p>\n<pre><code>function ensureCanMutateNextListeners() {\n  if (nextListeners === currentListeners) {\n    nextListeners = currentListeners.slice()\n  }\n}\n</code></pre><p>在每次 <code>dispatch</code> 之前，<code>subscriptions</code> 都会被 ‘snapshotted’，</p>\n<hr>\n<p>utils文件，以一个方便调试的方式打印错误信息。</p>\n<p>打印错误信息后，会抛出并捕获一个错误信息：</p>\n<pre><code>try {\n  throw new Error(&#39;...&#39;)\n} catch(err) {\n  // do nothing\n}\n</code></pre><p>以 Chrome 为例，如果打开 Pause on exceptions - Pause On Caught Exceptions 的话，会在此处暂停。</p>\n<hr>\n<p><code>compose</code> 方法</p>\n<p>接受多个函数，并从右往左连接起来，上一个函数的值为下一个函数的参数，最右的函数可接受多个参数。</p>\n<p>核心代码：</p>\n<pre><code>return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))\n</code></pre><hr>\n","raw":"---\nlayout: post\ntitle: redux 笔记\ncategories: [JavaScript, redux]\ntags: [JavaScript, React, redux]\ndate: 2016/11/13 20:46:25\n---\n\nstate 的改变必须经过 `store.dispatch` 方法，`dispatch` 方法会返回接收的 `action`。\n\n<!-- more -->\n\n## reducer\n\n### combineReducers\n\n```\n@param {Object} reducers An object whose values correspond to different reducer functions that need to be combined into one.\n@returns {Function} A reducer function that invokes every reducer inside the passed object, and builds a state object with the same shape.\n```\n\n接受多个 `reducer` 组成的 `object`，返回一个最终的 `reducer` 作为 `rootRecuer`。该 `reducer` 会将接收到的 `action` 分发给每一个接收到的 `reducer` 中。\n\n核心代码：\n```\nlet hasChanged = false\nconst nextState = {}\nfor (let i = 0; i < finalReducerKeys.length; i++) {\n  const key = finalReducerKeys[i]\n  const reducer = finalReducers[key]\n  const previousStateForKey = state[key]\n  const nextStateForKey = reducer(previousStateForKey, action)\n  if (typeof nextStateForKey === 'undefined') {\n    const errorMessage = getUndefinedStateErrorMessage(key, action)\n    throw new Error(errorMessage)\n  }\n  nextState[key] = nextStateForKey\n  hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n}\nreturn hasChanged ? nextState : state\n```\n\n因为最后返回的也是一个 `reducer` ，所以 `combineReducers` 方法可以嵌套使用。\n\n接收的参数对象的 key，对应 store state 的 key。\n例如 `combineReducers({ part1: reducer1, part12: reducer2 })`，对应的 store state 形如 `{ part1: state1, part2: state2 }`\n\n## middleware\n\n每个 middleware 会接收两个方法 `dispatch` and `getState` 作为 named arguments。传递方法来获得 store state 来保证每个 middleware 或得的 state 为最新的。\n\n形如 `({ dispatch, getState }) => next => action => {}`\n\n以 `redux-thunk` 为例：\n\n```\nfunction createThunkMiddleware(extraArgument) {\n  return ({ dispatch, getState }) => next => action => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return next(action);\n  };\n}\n\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n```\n\n### applyMiddleware\n\napplyMiddleware 的作用其实便是对 `store.dispatch` 的处理\n\n```\n@param {...Function} middlewares The middleware chain to be applied.\n@returns {Function} A store enhancer applying the middleware.\n```\n\n首先会获取加入 middleware 前的 `dispatch` 方法（最后返回的 `dispatch` 不一样，作为 fallback dispatch），并作为每个 `middleware` 的参数。\n\n```\nexport default function applyMiddleware(...middlewares) {\n  return (createStore) => (reducer, preloadedState, enhancer) => {\n    // enhancer will always be undefined\n    const store = createStore(reducer, preloadedState, enhancer)\n    // as middleware's named arguments and fallback dispatch\n    let dispatch = store.dispatch\n    let chain = []\n\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action) => dispatch(action)\n    }\n    // chain all middlewares together, and now every middleware now expects a next function and an action (thunk).\n    chain = middlewares.map(middleware => middleware(middlewareAPI))\n    dispatch = compose(...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n\n`applyMiddlewares` 这样实现的一个特性是，每一个 middleware 必须调用它的 `next` 方法，否则 chained middleware 会在此断掉。`next` 方法的参数即为下一个 middleware 的 `action`\n\n## 有趣的设计\n\n在 `createStore` 方法中\n\n```\nfunction ensureCanMutateNextListeners() {\n  if (nextListeners === currentListeners) {\n    nextListeners = currentListeners.slice()\n  }\n}\n```\n\n在每次 `dispatch` 之前，`subscriptions` 都会被 'snapshotted'，\n\n---\n\nutils文件，以一个方便调试的方式打印错误信息。\n\n打印错误信息后，会抛出并捕获一个错误信息：\n\n```\ntry {\n  throw new Error('...')\n} catch(err) {\n  // do nothing\n}\n```\n\n以 Chrome 为例，如果打开 Pause on exceptions - Pause On Caught Exceptions 的话，会在此处暂停。\n\n---\n\n`compose` 方法\n\n接受多个函数，并从右往左连接起来，上一个函数的值为下一个函数的参数，最右的函数可接受多个参数。\n\n核心代码：\n\n```\nreturn funcs.reduce((a, b) => (...args) => a(b(...args)))\n```\n\n---\n","photos":[],"title":"redux 笔记","date":"2016-11-13T12:46:25.000Z","updated":"2017-03-03T08:42:15.000Z","comments":true,"excerpt":"<p>state 的改变必须经过 <code>store.dispatch</code> 方法，<code>dispatch</code> 方法会返回接收的 <code>action</code>。</p>","path":"2016/11/13/redux/","permalink":"https://vanishingdante.github.io/gh-pages-blog-api/2016/11/13/redux/","link":"","published":true,"categories":["JavaScript","redux"],"tags":["JavaScript","React","redux"]}