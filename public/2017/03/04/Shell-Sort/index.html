{"content":"<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>\n<a id=\"more\"></a>\n<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率<br>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</p>\n<h3 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h3><p>将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。</p>\n<p>将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）。</p>\n<p>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样： </p>\n<pre><code>13 14 94 33 82\n25 59 94 65 23\n45 27 73 25 39\n10\n</code></pre><p>然后我们对每列进行排序：</p>\n<pre><code>10 14 73 25 23\n13 27 94 33 39\n25 59 94 65 82\n45\n</code></pre><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：</p>\n<pre><code>10 14 73\n25 23 13\n27 94 33\n39 25 59\n94 65 82\n45\n</code></pre><p>排序之后变为：</p>\n<pre><code>10 14 13\n25 23 33\n27 25 59\n39 65 73\n45 94 82\n94\n</code></pre><p>最后以1步长进行排序（此时就是简单的插入排序了）。</p>\n<h3 id=\"步长序列\"><a href=\"#步长序列\" class=\"headerlink\" title=\"步长序列\"></a>步长序列</h3><p>已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自 <code>9 * (4 ** i) - 9 * (2 ** i) + 1</code>，<code>(2 ** (i + 2)) * (2 ** (i + 2) - 3) + 1</code> 这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p>\n<h3 id=\"JavaScript-实现\"><a href=\"#JavaScript-实现\" class=\"headerlink\" title=\"JavaScript 实现\"></a>JavaScript 实现</h3><pre><code>const sort = (a, b) =&gt; {\n  if (a &gt; b) return [b, a]\n  if (b &gt; a) return [a, b]\n  return [a]\n}\n\nconst generateSequences = (arrLength) =&gt; {\n  const gap = arrLength / 2\n  const arr = []\n\n  for (let i = 0; ; i++) {\n    const a = 9 * (4 ** i) - 9 * (2 ** i) + 1\n    const b = (2 ** (i + 2)) * (2 ** (i + 2) - 3) + 1\n\n    arr.push(...sort(a, b))\n\n    if (a &gt; gap || b &gt; gap)\n      break\n  }\n\n  let index = arr.length - 1\n  while (arr[index] &gt; gap)\n    index--\n\n  return arr.slice(0, index + 1)\n}\n\nconst insertionSort = arr =&gt; {\n  const length = arr.length\n  if (length &lt;= 1) return arr\n\n  const insert = (start, end, toInsert) =&gt; {\n    const targetValue = arr[toInsert]\n\n    let index = end\n    while (index &gt;= start &amp;&amp; arr[index] &gt;= targetValue) {\n      index--\n    }\n    index++\n\n    for (let i = end + 1; i &gt; index; i--)\n      arr[i] = arr[i - 1]\n\n    arr[index] = targetValue\n  }\n\n  for (let i = 1; i &lt; length; i++) {\n    insert(0, i - 1, i)\n  }\n\n  return arr\n}\n</code></pre><hr>\n<p>完整的代码以及测试文件：<a href=\"https://github.com/VanishingDante/frequently-used-sort-algorithm\" target=\"_blank\" rel=\"external\">https://github.com/VanishingDante/frequently-used-sort-algorithm</a></p>\n","raw":"---\ntitle: Shell-Sort\ncategories: [JavaScript, algorithm, sort]\ntags: [JavaScript, sort, algorithm]\n---\n\n希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。\n\n<!-- more -->\n\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率\n但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位\n\n### 算法描述\n\n将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。\n\n将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）。\n\n\n例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样： \n\n```\n13 14 94 33 82\n25 59 94 65 23\n45 27 73 25 39\n10\n```\n\n然后我们对每列进行排序：\n\n```\n10 14 73 25 23\n13 27 94 33 39\n25 59 94 65 82\n45\n```\n\n将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：\n\n```\n10 14 73\n25 23 13\n27 94 33\n39 25 59\n94 65 82\n45\n```\n\n排序之后变为：\n\n```\n10 14 13\n25 23 33\n27 25 59\n39 65 73\n45 94 82\n94\n```\n\n最后以1步长进行排序（此时就是简单的插入排序了）。\n\n### 步长序列\n\n已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,...)，该序列的项来自 `9 * (4 ** i) - 9 * (2 ** i) + 1`，`(2 ** (i + 2)) * (2 ** (i + 2) - 3) + 1` 这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。\n\n### JavaScript 实现\n\n```\nconst sort = (a, b) => {\n  if (a > b) return [b, a]\n  if (b > a) return [a, b]\n  return [a]\n}\n\nconst generateSequences = (arrLength) => {\n  const gap = arrLength / 2\n  const arr = []\n\n  for (let i = 0; ; i++) {\n    const a = 9 * (4 ** i) - 9 * (2 ** i) + 1\n    const b = (2 ** (i + 2)) * (2 ** (i + 2) - 3) + 1\n\n    arr.push(...sort(a, b))\n\n    if (a > gap || b > gap)\n      break\n  }\n\n  let index = arr.length - 1\n  while (arr[index] > gap)\n    index--\n\n  return arr.slice(0, index + 1)\n}\n\nconst insertionSort = arr => {\n  const length = arr.length\n  if (length <= 1) return arr\n\n  const insert = (start, end, toInsert) => {\n    const targetValue = arr[toInsert]\n\n    let index = end\n    while (index >= start && arr[index] >= targetValue) {\n      index--\n    }\n    index++\n\n    for (let i = end + 1; i > index; i--)\n      arr[i] = arr[i - 1]\n\n    arr[index] = targetValue\n  }\n\n  for (let i = 1; i < length; i++) {\n    insert(0, i - 1, i)\n  }\n\n  return arr\n}\n\n```\n\n---\n\n完整的代码以及测试文件：[https://github.com/VanishingDante/frequently-used-sort-algorithm](https://github.com/VanishingDante/frequently-used-sort-algorithm)","photos":[],"title":"Shell-Sort","date":"2017-03-04T14:45:46.000Z","updated":"2017-03-04T15:03:43.000Z","comments":true,"excerpt":"<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>","path":"2017/03/04/Shell-Sort/","permalink":"https://vanishingdante.github.io/gh-pages-blog-api/2017/03/04/Shell-Sort/","link":"","published":true,"categories":["JavaScript","algorithm","sort"],"tags":["JavaScript","sort","algorithm"]}