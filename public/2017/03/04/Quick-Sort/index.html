{"content":"<p>快速排序是图灵奖得主 C. R. A. Hoare 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p>\n<a id=\"more\"></a>\n<p>利用分治法可将快速排序的分为三步：</p>\n<ol>\n<li>在数据集之中，选择一个元素作为”基准”（pivot）。</li>\n<li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。</li>\n<li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li>\n</ol>\n<hr>\n<p>快速排序的核心就是分区的实现，用伪代码表示如下</p>\n<pre><code>function partition(a, left, right, pivotIndex)\n  pivotValue := a[pivotIndex]\n  swap(a[pivotIndex], a[right]) // 把pivot移到結尾\n  storeIndex := left\n  for i from left to right-1\n    if a[i] &lt;＝ pivotValue\n      swap(a[storeIndex], a[i])\n      storeIndex := storeIndex + 1\n  swap(a[right], a[storeIndex]) // 把pivot移到它最後的地方\n  return storeIndex\n</code></pre><h3 id=\"JavaScript-实现\"><a href=\"#JavaScript-实现\" class=\"headerlink\" title=\"JavaScript 实现\"></a>JavaScript 实现</h3><p>在数组较小的时候，希尔排序等有着更好的表现。于是较小范围内不进行分区操作，改为直接排序。 </p>\n<pre><code>const shellSort = (arr, left, right) =&gt; {\n  const length = right - left + 1\n  if (length &lt;= 1) return arr\n\n  for (let gap = Math.floor(length / 2); gap &gt; 0; gap = Math.floor(gap / 2)) {\n    for (let group = left; group &lt; left + gap; group++) {\n      for (let target = group + gap; target &lt;= right; target += gap) {\n        const targetValue = arr[target]\n\n        let time = 1\n        while (target - time * gap &gt;= left &amp;&amp; targetValue &lt; arr[target - time * gap])\n          time++\n        time--\n\n        for (let n = 0; n &lt; time; n++)\n          arr[target - n * gap] = arr[target - n * gap - gap]\n\n        arr[target - time * gap] = targetValue\n      }\n\n    }\n  }\n\n  return arr\n}\n\nconst quickSort = arr =&gt; {\n  const par = (left, right) =&gt; {\n    const p = arr[right]\n    let index = left\n    for (let i = left; i &lt; right; i++)\n      if (arr[i] &lt; p) {\n        swap(arr, i, index)\n        index++\n      }\n\n    swap(arr, index, right)\n    return index\n  }\n\n  const sort = (left, right) =&gt; {\n    if (right - left &lt; 12)\n      return shellSort(arr, left, right)\n\n    const index = par(left, right)\n    sort(left, index - 1)\n    sort(index + 1, right)\n  }\n\n  sort(0, arr.length - 1)\n\n  return arr\n}\n</code></pre><hr>\n<p>完整的代码以及测试文件：<a href=\"https://github.com/VanishingDante/frequently-used-sort-algorithm\" target=\"_blank\" rel=\"external\">https://github.com/VanishingDante/frequently-used-sort-algorithm</a></p>\n","raw":"---\ntitle: Quick-Sort\ncategories: [JavaScript, algorithm, sort]\ntags: [JavaScript, sort, algorithm]\n---\n\n快速排序是图灵奖得主 C. R. A. Hoare 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。\n\n<!-- more -->\n\n利用分治法可将快速排序的分为三步：\n\n1. 在数据集之中，选择一个元素作为”基准”（pivot）。\n2. 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。\n3. 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。\n\n---\n\n快速排序的核心就是分区的实现，用伪代码表示如下\n```\nfunction partition(a, left, right, pivotIndex)\n  pivotValue := a[pivotIndex]\n  swap(a[pivotIndex], a[right]) // 把pivot移到結尾\n  storeIndex := left\n  for i from left to right-1\n    if a[i] <＝ pivotValue\n      swap(a[storeIndex], a[i])\n      storeIndex := storeIndex + 1\n  swap(a[right], a[storeIndex]) // 把pivot移到它最後的地方\n  return storeIndex\n```\n\n### JavaScript 实现    \n\n在数组较小的时候，希尔排序等有着更好的表现。于是较小范围内不进行分区操作，改为直接排序。 \n\n```\nconst shellSort = (arr, left, right) => {\n  const length = right - left + 1\n  if (length <= 1) return arr\n\n  for (let gap = Math.floor(length / 2); gap > 0; gap = Math.floor(gap / 2)) {\n    for (let group = left; group < left + gap; group++) {\n      for (let target = group + gap; target <= right; target += gap) {\n        const targetValue = arr[target]\n\n        let time = 1\n        while (target - time * gap >= left && targetValue < arr[target - time * gap])\n          time++\n        time--\n\n        for (let n = 0; n < time; n++)\n          arr[target - n * gap] = arr[target - n * gap - gap]\n\n        arr[target - time * gap] = targetValue\n      }\n\n    }\n  }\n\n  return arr\n}\n\nconst quickSort = arr => {\n  const par = (left, right) => {\n    const p = arr[right]\n    let index = left\n    for (let i = left; i < right; i++)\n      if (arr[i] < p) {\n        swap(arr, i, index)\n        index++\n      }\n\n    swap(arr, index, right)\n    return index\n  }\n\n  const sort = (left, right) => {\n    if (right - left < 12)\n      return shellSort(arr, left, right)\n\n    const index = par(left, right)\n    sort(left, index - 1)\n    sort(index + 1, right)\n  }\n\n  sort(0, arr.length - 1)\n\n  return arr\n}\n```  \n\n---\n\n完整的代码以及测试文件：[https://github.com/VanishingDante/frequently-used-sort-algorithm](https://github.com/VanishingDante/frequently-used-sort-algorithm)","photos":[],"title":"Quick-Sort","date":"2017-03-04T14:52:09.000Z","updated":"2017-03-04T15:03:23.000Z","comments":true,"excerpt":"<p>快速排序是图灵奖得主 C. R. A. Hoare 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p>","path":"2017/03/04/Quick-Sort/","permalink":"https://vanishingdante.github.io/gh-pages-blog-api/2017/03/04/Quick-Sort/","link":"","published":true,"categories":["JavaScript","algorithm","sort"],"tags":["JavaScript","sort","algorithm"]}