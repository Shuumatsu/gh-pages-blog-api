{"content":"<p>问题来自 <a href=\"https://stackoverflow.com/questions/406230/regular-expression-to-match-a-line-that-doesnt-contain-a-word\" target=\"_blank\" rel=\"external\">Stack Overflow</a>.</p>\n<p>Regular expression to match a line that doesn’t contain a word?</p>\n<a id=\"more\"></a>\n<h3 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h3><p><code>/^((?!hede).)*$/</code> 会匹配任何一个不包含 <code>&#39;hede&#39;</code> 子串的单行字符串，如果要让他支持多行字符串，将 <code>*</code> 替换为 <code>(\\n|.)</code> 即可。</p>\n<p><code>/^(?!hede).*$/</code> 是不以 <code>&#39;hede&#39;</code> 开头的版本。</p>\n<h3 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h3><h4 id=\"正则表达式原理\"><a href=\"#正则表达式原理\" class=\"headerlink\" title=\"正则表达式原理\"></a>正则表达式原理</h4><p>来自 <a href=\"https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\" target=\"_blank\" rel=\"external\">Wikipedia</a>:</p>\n<p>正则表达式可以用形式化语言理论的方式来表达。正则表达式由常量和算子组成，它们分别指示字符串的集合和在这些集合上的运算。给定有限字母表Σ定义了下列常量：</p>\n<ul>\n<li><p>（“空集”）∅指示集合∅</p>\n</li>\n<li><p>（“空串”）ε指示集合{ε}</p>\n</li>\n<li><p>（“文字字符”）在Σ中的a指示集合{a}</p>\n</li>\n</ul>\n<p>定义了下列运算：</p>\n<ul>\n<li><p>（“串接”）RS指示集合{ αβ | α ∈ R，β ∈ S }。例如：{“ab”,”c”}{“d”,”ef”} = {“abd”, “abef”, “cd”, “cef”}。</p>\n</li>\n<li><p>（“选择”）R|S指示R和S的并集。例如：{“ab”, “c”}|{“ab”, “d”, “ef”}= {“ab”, “c”, “d”, “ef”}。</p>\n</li>\n<li><p>（“Kleene星号”）R* 指示包含ε并且闭合在字符串串接下的R的最小超集。这是可以通过R中的零或多个字符串的串接得到所有字符串的集合。例如，{“ab”, “c”}* = {ε, “ab”, “c”, “abab”, “abc”, “cab”, “cc”, “ababab”, … }。</p>\n</li>\n</ul>\n<p>上述常量和算子形成了克莱尼代数。</p>\n<p>选择运算拥有最低的优先级，例如 <code>/gray|grey/</code> 等同于 <code>/gr(a|e)y/</code>。</p>\n<h4 id=\"字符串分析\"><a href=\"#字符串分析\" class=\"headerlink\" title=\"字符串分析\"></a>字符串分析</h4><p>一个字符串相当于是一串字符。没个字符的前后可看作有一个空字符串。这样来看的话，一个长度为 n 的字符串会有 n+1 个空字符串。</p>\n<pre><code>\n    ┌──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┐\nS = │e1│ A │e2│ B │e3│ h │e4│ e │e5│ d │e6│ e │e7│ C │e8│ D │e9│\n    └──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┘\n\nindex    0      1      2      3      4      5      6      7\n</code></pre><h4 id=\"正向否定预查\"><a href=\"#正向否定预查\" class=\"headerlink\" title=\"正向否定预查\"></a>正向否定预查</h4><p><code>(?!pattern)</code> 是正向否定预查。来自 <a href=\"https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\" target=\"_blank\" rel=\"external\">Wikipedia</a> 的解释是：</p>\n<blockquote>\n<p>正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</p>\n</blockquote>\n<p>所以会有以下这些结果：</p>\n<pre><code>// true\n/Windows(?!95|98|NT|2000)/.test(&#39;Windows&#39;)\n\n// true\n/Windows(?!95|98|NT|2000)/.test(&#39;Windows10&#39;)\n\n// false\n/Windows(?!95|98|NT|2000)/.test(&#39;Windows95&#39;)\n\n// [&quot;Windows10&quot;, &quot;10&quot;]\n/Windows(?!95|98|NT|2000)(\\d+)/.exec(&#39;Windows10&#39;)\n</code></pre><h4 id=\"hede\"><a href=\"#hede\" class=\"headerlink\" title=\"/^((?!hede).)*$/\"></a>/^((?!hede).)*$/</h4><p>再回到我们的 <code>/^((?!hede).)*$/</code>，表达式的 <code>(?!hede)</code> 部分会向右看是否有 <code>&#39;hede&#39;</code> 子串，如果没有的话 <code>.</code>(dot)会匹配任何除了换行符外的其他字符。预查（look-arounds，是叫这个意思吧）也叫做 zero-width-assertions，因为不会消耗任何字符，仅仅是去验证。</p>\n<p>所以在这个例子中，每一个空字符串都会首先去验证它左边是否有一个 <code>&#39;hede&#39;</code> 子串。这样重复下去，直到没一个字符都被 <code>.</code>(dot) 消耗。</p>\n<p>As you can see, the input “ABhedeCD” will fail because on e3, the regex (?!hede) fails (there is “hede” up ahead!).</p>\n","raw":"---\ntitle: don't match in regex\ndate: 2017-03-06 15:53:34\ntags: [regex]\ncategories: [regex]\n---\n\n问题来自 [Stack Overflow](https://stackoverflow.com/questions/406230/regular-expression-to-match-a-line-that-doesnt-contain-a-word).\n\nRegular expression to match a line that doesn't contain a word?\n\n<!-- more -->\n\n### 答案\n\n`/^((?!hede).)*$/` 会匹配任何一个不包含 `'hede'` 子串的单行字符串，如果要让他支持多行字符串，将 `*` 替换为 `(\\n|.)` 即可。\n\n`/^(?!hede).*$/` 是不以 `'hede'` 开头的版本。\n\n### 解释\n\n\n#### 正则表达式原理\n\n来自 [Wikipedia](https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F):\n\n正则表达式可以用形式化语言理论的方式来表达。正则表达式由常量和算子组成，它们分别指示字符串的集合和在这些集合上的运算。给定有限字母表Σ定义了下列常量：\n\n- （“空集”）∅指示集合∅\n\n- （“空串”）ε指示集合{ε}\n\n- （“文字字符”）在Σ中的a指示集合{a}\n\n定义了下列运算：\n\n- （“串接”）RS指示集合{ αβ | α ∈ R，β ∈ S }。例如：{\"ab\",\"c\"}{\"d\",\"ef\"} = {\"abd\", \"abef\", \"cd\", \"cef\"}。\n\n- （“选择”）R|S指示R和S的并集。例如：{\"ab\", \"c\"}|{\"ab\", \"d\", \"ef\"}= {\"ab\", \"c\", \"d\", \"ef\"}。\n\n- （“Kleene星号”）R\\* 指示包含ε并且闭合在字符串串接下的R的最小超集。这是可以通过R中的零或多个字符串的串接得到所有字符串的集合。例如，{\"ab\", \"c\"}\\* = {ε, \"ab\", \"c\", \"abab\", \"abc\", \"cab\", \"cc\", \"ababab\", ... }。\n\n上述常量和算子形成了克莱尼代数。\n\n选择运算拥有最低的优先级，例如 `/gray|grey/` 等同于 `/gr(a|e)y/`。\n\n#### 字符串分析\n\n一个字符串相当于是一串字符。没个字符的前后可看作有一个空字符串。这样来看的话，一个长度为 n 的字符串会有 n+1 个空字符串。\n\n```\n\n    ┌──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┐\nS = │e1│ A │e2│ B │e3│ h │e4│ e │e5│ d │e6│ e │e7│ C │e8│ D │e9│\n    └──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┘\n\nindex    0      1      2      3      4      5      6      7\n```\n\n#### 正向否定预查\n\n`(?!pattern)` 是正向否定预查。来自 [Wikipedia](https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F) 的解释是：\n\n>正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始\n\n所以会有以下这些结果：\n\n```\n// true\n/Windows(?!95|98|NT|2000)/.test('Windows')\n\n// true\n/Windows(?!95|98|NT|2000)/.test('Windows10')\n\n// false\n/Windows(?!95|98|NT|2000)/.test('Windows95')\n\n// [\"Windows10\", \"10\"]\n/Windows(?!95|98|NT|2000)(\\d+)/.exec('Windows10')\n```\n\n#### /^((?!hede).)*$/\n\n再回到我们的 `/^((?!hede).)*$/`，表达式的 `(?!hede)` 部分会向右看是否有 `'hede'` 子串，如果没有的话 `.`(dot)会匹配任何除了换行符外的其他字符。预查（look-arounds，是叫这个意思吧）也叫做 zero-width-assertions，因为不会消耗任何字符，仅仅是去验证。\n\n所以在这个例子中，每一个空字符串都会首先去验证它左边是否有一个 `'hede'` 子串。这样重复下去，直到没一个字符都被 `.`(dot) 消耗。\n\nAs you can see, the input \"ABhedeCD\" will fail because on e3, the regex (?!hede) fails (there is \"hede\" up ahead!).\n\n","photos":[],"title":"don't match in regex","date":"2017-03-06T07:53:34.000Z","updated":"2017-03-06T18:17:38.000Z","comments":true,"excerpt":"<p>问题来自 <a href=\"https://stackoverflow.com/questions/406230/regular-expression-to-match-a-line-that-doesnt-contain-a-word\">Stack Overflow</a>.</p>\n<p>Regular expression to match a line that doesn’t contain a word?</p>","path":"2017/03/06/don't match in regex/","permalink":"https://vanishingdante.github.io/gh-pages-blog-api/2017/03/06/don't match in regex/","link":"","published":true,"categories":["regex"],"tags":["regex"]}