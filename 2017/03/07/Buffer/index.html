{"content":"<p>用外行人的话来说，可以将 buffer 比做一个碗。想象你正在吃一个碗里的糖。你有规律的取出来，为了避免碗空，有人就会在碗空之前再填充它。这样的话，当你想从碗中取糖的时候，碗里始终有糖。</p>\n<p>当你在线看电影的时候，网络服务会不断的下载接下来的 5 分钟的内容到 buffer，这样看电影的时候就不需要下载这个电影。</p>\n<a id=\"more\"></a>\n<h3 id=\"buffer-释义\"><a href=\"#buffer-释义\" class=\"headerlink\" title=\"buffer 释义\"></a>buffer 释义</h3><p>在计算机科学中，一个 data buffer 就是物理内存中的一段在数据被从一个地方移到另一个地方时被用来暂时储存数据的区域。一般来说，数据从输入设备获取到（例如麦克风），被送到输出设备前时（例如扬声器），被存储在 buffer。Buffer 也被用在计算机进程间的传递数据。</p>\n<p>Buffer 可以在硬件上用一块固定的内存区实现，也可以在软件上用一块虚拟的 data buffer 指向内存中的区域来实现。总之，data buffer 中的数据是被存储来一个物理存储介质上。</p>\n<p>大部分的 buffers 都是软件实现，一般使用较快的内存来存储数据，这样数据的获取时间会比硬盘快很多。一般 buffers被用在数据的获取与处理不相当时，例如视频在线缓冲时。（Buffers are typically used when there is a difference between the rate at which data is received and the rate at which it can be processed, or in the case that these rates are variable, for example in a printer spooler or in online video streaming.）</p>\n<p>Buffer 经常在内存中实现一个队列算法，同时以一定的速率写入数据，以另一个速率来获取数据。</p>\n<h3 id=\"buffer-in-node\"><a href=\"#buffer-in-node\" class=\"headerlink\" title=\"buffer in node\"></a>buffer in node</h3><p>JavaScript 能很好的处理 unicode-encoded 字符串，但是并不能很好处理直接的二进制数据。Node 服务器 需要处理 TCP 流，从中读取并写入数据到文件系统，这使得 JavaScript 很有必要的去处理纯二进制数据流。所以 Node 提供了 Buffer。</p>\n<p>Node 的 buffer 基于 es2015 的 Uint8Array。Buffer 类的实例和一个由整数组成的数组很相似，但是它有着固定的大小，raw memory allocations outside the V8 heap. Buffer 的大小在创建时就被确定，不能更改。Buffer 中的每一个整数都代表一个 byte，所以它们的值被限制在 0 到 255 (2^8 - 1)。</p>\n<p>In the wild, buffers are usually seen in the context of binary data coming from streams, such as fs.createReadStream.</p>\n<h4 id=\"创建-buffer\"><a href=\"#创建-buffer\" class=\"headerlink\" title=\"创建 buffer\"></a>创建 buffer</h4><pre><code>// Creates a zero-filled Buffer of length 10.\nconst buf1 = Buffer.alloc(10);\n\n// Creates a Buffer of length 10, filled with 0x1.\nconst buf2 = Buffer.alloc(10, 1);\n\n// Creates an uninitialized buffer of length 10.\n// This is faster than calling Buffer.alloc() but the returned\n// Buffer instance might contain old data that needs to be\n// overwritten using either fill() or write().\nconst buf3 = Buffer.allocUnsafe(10);\n\n// Creates a Buffer containing [0x1, 0x2, 0x3].\nconst buf4 = Buffer.from([1, 2, 3]);\n\n// Creates a Buffer containing ASCII bytes [0x74, 0x65, 0x73, 0x74].\nconst buf5 = Buffer.from(&#39;test&#39;);\n\n// Creates a Buffer containing UTF-8 bytes [0x74, 0xc3, 0xa9, 0x73, 0x74].\nconst buf6 = Buffer.from(&#39;tést&#39;, &#39;utf8&#39;);\n</code></pre><p>The character encodings currently supported by Node.js include:</p>\n<ul>\n<li><p>‘ascii’ - for 7-bit ASCII data only. This encoding is fast and will strip the high bit if set.</p>\n</li>\n<li><p>‘utf8’ - Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.</p>\n</li>\n<li><p>‘utf16le’ - 2 or 4 bytes, little-endian encoded Unicode characters. Surrogate pairs (U+10000 to U+10FFFF) are supported.</p>\n</li>\n<li><p>‘ucs2’ - Alias of ‘utf16le’.</p>\n</li>\n<li><p>‘base64’ - Base64 encoding. When creating a Buffer from a string, this encoding will also correctly accept “URL and Filename Safe Alphabet” as specified in RFC4648, Section 5.</p>\n</li>\n<li><p>‘latin1’ - A way of encoding the Buffer into a one-byte encoded string (as defined by the IANA in RFC1345, page 63, to be the Latin-1 supplement block and C0/C1 control codes).</p>\n</li>\n<li><p>‘binary’ - Alias for ‘latin1’.</p>\n</li>\n<li><p>‘hex’ - Encode each byte as two hexadecimal characters.</p>\n</li>\n</ul>\n<h4 id=\"buffer-length\"><a href=\"#buffer-length\" class=\"headerlink\" title=\"buffer.length\"></a>buffer.length</h4><p>buffer.length returns the amount of memory allocated for buf in bytes.</p>\n<pre><code>const buf = Buffer.alloc(1234)\n\n// Prints: 1234\nconsole.log(buf.length)\n</code></pre><h4 id=\"buffer-slice\"><a href=\"#buffer-slice\" class=\"headerlink\" title=\"buffer.slice\"></a>buffer.slice</h4><p>与数组的 slice 方法不同，不像数组那样会新建一个数组，而是新建了一个引用，在新的 buffer 上的修改也是对原 buffer 的修改。</p>\n<pre><code>const buf = Buffer.from([1, 2, 3])\nbuf.slice(1)[0] = 5\n\nbuf[1] === 5\n</code></pre>","raw":"---\ntitle: Buffer\ndate: 2017-03-07 22:19:40\ntags: [JavaScript, Node, Buffer]\n---\n\n用外行人的话来说，可以将 buffer 比做一个碗。想象你正在吃一个碗里的糖。你有规律的取出来，为了避免碗空，有人就会在碗空之前再填充它。这样的话，当你想从碗中取糖的时候，碗里始终有糖。\n\n当你在线看电影的时候，网络服务会不断的下载接下来的 5 分钟的内容到 buffer，这样看电影的时候就不需要下载这个电影。\n\n<!--more-->\n\n### buffer 释义\n\n在计算机科学中，一个 data buffer 就是物理内存中的一段在数据被从一个地方移到另一个地方时被用来暂时储存数据的区域。一般来说，数据从输入设备获取到（例如麦克风），被送到输出设备前时（例如扬声器），被存储在 buffer。Buffer 也被用在计算机进程间的传递数据。\n\nBuffer 可以在硬件上用一块固定的内存区实现，也可以在软件上用一块虚拟的 data buffer 指向内存中的区域来实现。总之，data buffer 中的数据是被存储来一个物理存储介质上。\n\n大部分的 buffers 都是软件实现，一般使用较快的内存来存储数据，这样数据的获取时间会比硬盘快很多。一般 buffers被用在数据的获取与处理不相当时，例如视频在线缓冲时。（Buffers are typically used when there is a difference between the rate at which data is received and the rate at which it can be processed, or in the case that these rates are variable, for example in a printer spooler or in online video streaming.）\n\nBuffer 经常在内存中实现一个队列算法，同时以一定的速率写入数据，以另一个速率来获取数据。\n\n### buffer in node\n\nJavaScript 能很好的处理 unicode-encoded 字符串，但是并不能很好处理直接的二进制数据。Node 服务器 需要处理 TCP 流，从中读取并写入数据到文件系统，这使得 JavaScript 很有必要的去处理纯二进制数据流。所以 Node 提供了 Buffer。\n\nNode 的 buffer 基于 es2015 的 Uint8Array。Buffer 类的实例和一个由整数组成的数组很相似，但是它有着固定的大小，raw memory allocations outside the V8 heap. Buffer 的大小在创建时就被确定，不能更改。Buffer 中的每一个整数都代表一个 byte，所以它们的值被限制在 0 到 255 (2^8 - 1)。\n\n\nIn the wild, buffers are usually seen in the context of binary data coming from streams, such as fs.createReadStream.\n\n#### 创建 buffer\n\n```\n// Creates a zero-filled Buffer of length 10.\nconst buf1 = Buffer.alloc(10);\n\n// Creates a Buffer of length 10, filled with 0x1.\nconst buf2 = Buffer.alloc(10, 1);\n\n// Creates an uninitialized buffer of length 10.\n// This is faster than calling Buffer.alloc() but the returned\n// Buffer instance might contain old data that needs to be\n// overwritten using either fill() or write().\nconst buf3 = Buffer.allocUnsafe(10);\n\n// Creates a Buffer containing [0x1, 0x2, 0x3].\nconst buf4 = Buffer.from([1, 2, 3]);\n\n// Creates a Buffer containing ASCII bytes [0x74, 0x65, 0x73, 0x74].\nconst buf5 = Buffer.from('test');\n\n// Creates a Buffer containing UTF-8 bytes [0x74, 0xc3, 0xa9, 0x73, 0x74].\nconst buf6 = Buffer.from('tést', 'utf8');\n```\n\nThe character encodings currently supported by Node.js include:\n\n- 'ascii' - for 7-bit ASCII data only. This encoding is fast and will strip the high bit if set.\n\n- 'utf8' - Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\n\n- 'utf16le' - 2 or 4 bytes, little-endian encoded Unicode characters. Surrogate pairs (U+10000 to U+10FFFF) are supported.\n\n- 'ucs2' - Alias of 'utf16le'.\n\n- 'base64' - Base64 encoding. When creating a Buffer from a string, this encoding will also correctly accept \"URL and Filename Safe Alphabet\" as specified in RFC4648, Section 5.\n\n- 'latin1' - A way of encoding the Buffer into a one-byte encoded string (as defined by the IANA in RFC1345, page 63, to be the Latin-1 supplement block and C0/C1 control codes).\n\n- 'binary' - Alias for 'latin1'.\n\n- 'hex' - Encode each byte as two hexadecimal characters.\n\n#### buffer.length\n\nbuffer.length returns the amount of memory allocated for buf in bytes.\n\n```\nconst buf = Buffer.alloc(1234)\n\n// Prints: 1234\nconsole.log(buf.length)\n```\n\n#### buffer.slice\n\n与数组的 slice 方法不同，不像数组那样会新建一个数组，而是新建了一个引用，在新的 buffer 上的修改也是对原 buffer 的修改。\n\n```\nconst buf = Buffer.from([1, 2, 3])\nbuf.slice(1)[0] = 5\n\nbuf[1] === 5\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","photos":[],"title":"Buffer","date":"2017-03-07T14:19:40.000Z","updated":"2017-03-07T14:20:14.000Z","comments":true,"excerpt":"<p>用外行人的话来说，可以将 buffer 比做一个碗。想象你正在吃一个碗里的糖。你有规律的取出来，为了避免碗空，有人就会在碗空之前再填充它。这样的话，当你想从碗中取糖的时候，碗里始终有糖。</p>\n<p>当你在线看电影的时候，网络服务会不断的下载接下来的 5 分钟的内容到 buffer，这样看电影的时候就不需要下载这个电影。</p>","path":"2017/03/07/Buffer/","permalink":"https://vanishingdante.github.io/gh-pages-blog-api/2017/03/07/Buffer/","link":"","published":true,"categories":[],"tags":["JavaScript","Node","Buffer"]}