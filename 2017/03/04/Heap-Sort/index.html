{"content":"<p>堆（二叉堆）可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。</p>\n<a id=\"more\"></a>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><p>因为堆的这个性质，对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标</p>\n<pre><code>const getParent = i =&gt; {\n  if (i % 2 === 0) return i / 2 - 1\n  return i / 2 - 0.5\n}\n\nconst parent = getParent(i)\nconst leftChild = i * 2 + 1\nconst rightChild = i * 2 + 2\n</code></pre><h3 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h3><p>堆的实现通过构造二叉堆（binary heap），实为二叉树的一种；由于其应用的普遍性，当不加限定时，均指该数据结构的这种实现。这种数据结构具有以下性质。</p>\n<ul>\n<li><p>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。</p>\n</li>\n<li><p>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</p>\n</li>\n</ul>\n<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p>\n<h3 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h3><p>以最小堆为例，构造堆的关键是保证每个节点和他的子节点以及父节点的关系。<br>流程如下：</p>\n<p><img src=\"building-a-heap.png\" alt=\"building-a-heap\"></p>\n<p>可通过以下两个函数来保证：</p>\n<pre><code>// ensure element at index is larger than its parent\n// and iterate up\nconst up = (arr, index) =&gt; {\n  let i = index\n\n  while (true) {\n    const parent = Math.floor(i / 2)\n\n    if (parent &lt;= 0 || arr[parent] &lt; arr[i]) break\n\n    swap(arr, i, parent)\n    i = parent\n  }\n\n  return i &lt; index\n}\n\n// ensure element at index is smaller than its direct child\n// and iterate down\nconst down = (arr, index) =&gt; {\n  const size = arr.length\n  let i = index\n\n  while (true) {\n    const left = i * 2 + 1\n    if (left &gt;= size) break\n\n    const right = left + 1\n    let j = left\n    if (right &lt; size &amp;&amp; arr[right] &lt; arr[left])\n      j = right\n\n    if (arr[i] &lt; arr[j]) break\n\n    swap(arr, i, j)\n    i = j\n  }\n\n  return i &gt; index\n}\n</code></pre><p>将一般数组排为堆：</p>\n<pre><code>const init = arr =&gt; {\n  const size = arr.length\n  for (let i = getParent(size - 1); i &gt;= 0; i--)\n    down(arr, i)\n\n  return arr\n}\n\nconst fix = (arr, index) =&gt; down(arr, index) &amp;&amp; up(arr, index)\n\nexport default class Heap {\n\n  get size() {\n    return this.store.length\n  }\n\n  constructor(arr = []) {\n    this.store = init(arr)\n  }\n\n  push(el) {\n    this.store.push(el)\n    up(this.store, this.size - 1)\n  }\n\n  pop() {\n    swap(this.store, 0, this.size - 1)\n    const el = this.store.pop()\n    down(this.store, 0)\n\n    return el\n  }\n\n  remove(index) {\n    this.store[index] = this.store.pop()\n    fix(this.store, index)\n  }\n}\n</code></pre><h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><p>堆排序（Heap-Sort）是堆排序的接口算法，Heap-Sort先将数组改造为最大堆，然后将堆顶和堆底元素交换，之后将底部上升，最后重新调用 down 保持最大堆性质。由于堆顶元素必然是堆中最大的元素，所以一次操作之后，堆中存在的最大元素被分离出堆，重复n-1次之后，数组排列完毕。整个流程如下：</p>\n<p><img src=\"HeapSort.png\" alt=\"HeapSort\"></p>\n<p>用 JavaScript 代码表示如下：</p>\n<pre><code>const hs = arr =&gt; {\n  init(arr)\n\n  for (let i = arr.length - 1; i &gt; 0; i--) {\n    swap(arr, 0, i)\n    down(arr, 0, i - 1)\n  }\n\n  return arr\n}\n</code></pre><hr>\n<p>完整的代码以及测试文件：<a href=\"https://github.com/VanishingDante/frequently-used-sort-algorithm\" target=\"_blank\" rel=\"external\">https://github.com/VanishingDante/frequently-used-sort-algorithm</a></p>\n","raw":"---\ntitle: Heap-Sort\ncategories: [JavaScript, algorithm, sort]\ntags: [JavaScript, sort, algorithm, data structure]\n---\n\n堆（二叉堆）可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。\n\n<!-- more -->\n\n### 堆\n\n因为堆的这个性质，对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标\n\n```\nconst getParent = i => {\n  if (i % 2 === 0) return i / 2 - 1\n  return i / 2 - 0.5\n}\n\nconst parent = getParent(i)\nconst leftChild = i * 2 + 1\nconst rightChild = i * 2 + 2\n```\n\n### 性质\n\n堆的实现通过构造二叉堆（binary heap），实为二叉树的一种；由于其应用的普遍性，当不加限定时，均指该数据结构的这种实现。这种数据结构具有以下性质。\n\n- 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。\n\n- 堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。\n\n将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。\n\n### 构造\n\n以最小堆为例，构造堆的关键是保证每个节点和他的子节点以及父节点的关系。\n流程如下：\n\n![building-a-heap](building-a-heap.png)\n\n可通过以下两个函数来保证：\n\n```\n// ensure element at index is larger than its parent\n// and iterate up\nconst up = (arr, index) => {\n  let i = index\n\n  while (true) {\n    const parent = Math.floor(i / 2)\n\n    if (parent <= 0 || arr[parent] < arr[i]) break\n\n    swap(arr, i, parent)\n    i = parent\n  }\n\n  return i < index\n}\n\n// ensure element at index is smaller than its direct child\n// and iterate down\nconst down = (arr, index) => {\n  const size = arr.length\n  let i = index\n\n  while (true) {\n    const left = i * 2 + 1\n    if (left >= size) break\n\n    const right = left + 1\n    let j = left\n    if (right < size && arr[right] < arr[left])\n      j = right\n\n    if (arr[i] < arr[j]) break\n\n    swap(arr, i, j)\n    i = j\n  }\n\n  return i > index\n}\n```\n\n将一般数组排为堆：\n```\nconst init = arr => {\n  const size = arr.length\n  for (let i = getParent(size - 1); i >= 0; i--)\n    down(arr, i)\n\n  return arr\n}\n\nconst fix = (arr, index) => down(arr, index) && up(arr, index)\n\nexport default class Heap {\n\n  get size() {\n    return this.store.length\n  }\n\n  constructor(arr = []) {\n    this.store = init(arr)\n  }\n\n  push(el) {\n    this.store.push(el)\n    up(this.store, this.size - 1)\n  }\n\n  pop() {\n    swap(this.store, 0, this.size - 1)\n    const el = this.store.pop()\n    down(this.store, 0)\n\n    return el\n  }\n\n  remove(index) {\n    this.store[index] = this.store.pop()\n    fix(this.store, index)\n  }\n}\n```\n\n### 堆排序\n\n堆排序（Heap-Sort）是堆排序的接口算法，Heap-Sort先将数组改造为最大堆，然后将堆顶和堆底元素交换，之后将底部上升，最后重新调用 down 保持最大堆性质。由于堆顶元素必然是堆中最大的元素，所以一次操作之后，堆中存在的最大元素被分离出堆，重复n-1次之后，数组排列完毕。整个流程如下：\n\n![HeapSort](HeapSort.png)\n\n用 JavaScript 代码表示如下：\n```\nconst hs = arr => {\n  init(arr)\n\n  for (let i = arr.length - 1; i > 0; i--) {\n    swap(arr, 0, i)\n    down(arr, 0, i - 1)\n  }\n\n  return arr\n}\n```\n\n---\n\n完整的代码以及测试文件：[https://github.com/VanishingDante/frequently-used-sort-algorithm](https://github.com/VanishingDante/frequently-used-sort-algorithm)","photos":[],"title":"Heap-Sort","date":"2017-03-04T14:07:06.000Z","updated":"2017-03-04T15:03:50.000Z","comments":true,"excerpt":"<p>堆（二叉堆）可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。</p>","path":"2017/03/04/Heap-Sort/","permalink":"https://vanishingdante.github.io/gh-pages-blog-api/2017/03/04/Heap-Sort/","link":"","published":true,"categories":["JavaScript","algorithm","sort"],"tags":["JavaScript","sort","algorithm","data structure"]}