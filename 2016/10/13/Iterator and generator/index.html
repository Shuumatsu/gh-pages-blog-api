{"content":"<p>iterator 与 generator 以及后续的 async await</p>\n<a id=\"more\"></a>\n<h2 id=\"iterator\"><a href=\"#iterator\" class=\"headerlink\" title=\"iterator\"></a>iterator</h2><h3 id=\"可遍历（可迭代）协议\"><a href=\"#可遍历（可迭代）协议\" class=\"headerlink\" title=\"可遍历（可迭代）协议\"></a>可遍历（可迭代）协议</h3><p>一个对象为了变成可遍历对象，比如说可以用 <code>for ... in</code> 结构遍历其属性值，必须实现 <code>@@iterator</code> 方法, 意思是这个对象（或者它原型链 <code>prototype chain</code> 上的某个对象）必须有一个名字是 <code>Symbol.iterator</code> 的属性。<br>|属性|值|<br>|—|—|<br>|<code>[Symbol.iterator]</code>|返回一个对象的无参函数，被返回对象符合可遍历协议。|</p>\n<h3 id=\"迭代器协议\"><a href=\"#迭代器协议\" class=\"headerlink\" title=\"迭代器协议\"></a>迭代器协议</h3><p>当一个对象被认为是一个迭代器时，它实现了一个 <code>next()</code> 的方法。<br>该方法返回一个对象包含 <code>done</code> 和 <code>value</code> 属性，<code>done</code> 的值表示迭代器是否可以产生序列中的下一个值，<code>value</code> 为迭代器返回的任何 <code>JavaScript</code> 值。<code>done</code> 为 <code>true</code> 时可省略。</p>\n<hr>\n<pre><code>let a = {\n    q: &#39;q&#39;,\n    w: &#39;w&#39;,\n    e: &#39;e&#39;,\n};\nObject.defineProperty(a, length, {\n    enumerable: false,\n    value: 3\n});\n</code></pre><p>现在对 a 尝试用 <code>for ... in</code> 结构遍历其属性值</p>\n<pre><code>for (let v of a) {\n    console.log(v);\n}\n</code></pre><p>报错：</p>\n<pre><code>Uncaught TypeError: a[Symbol.iterator] is not a function\n</code></pre><p>定义一个函数利用闭包实现一个将 <code>a</code> 转变为可迭代对象</p>\n<pre><code>function Iterator(obj) {\n    let i;\n\n    return ()=&gt; {\n        return {\n            next: ()=&gt; {\n                if (i &lt; obj.length) {\n                    for (i in obj) {\n                        return {\n                            done: false,\n                            value: obj[i]\n                        };\n                    }\n                }\n                return {\n                    done: true\n                };\n            }\n        };\n    };\n}\n\na[Symbol.iterator] = Iterator(a);\n</code></pre><h2 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h2><p><code>Generator</code> 函数最大特点就是可以交出函数的执行权（即暂停执行）。异步操作需要暂停的地方，都用 yield 语句注明。调用 <code>Generator</code> 函数并不会执行本体，而是每次调用 <code>next</code> 方法的时候，执行到下一个碰到的 <code>yield</code> 处。</p>\n<h3 id=\"Generator-函数的数据交换\"><a href=\"#Generator-函数的数据交换\" class=\"headerlink\" title=\"Generator 函数的数据交换\"></a>Generator 函数的数据交换</h3><pre><code>function* anotherGenerator(i) {\n  yield i + 1;\n  let x = yield i + 2;\n  yield x + 3;\n}\n\nfunction* generator(i){\n  yield i;\n  yield* anotherGenerator(i);\n  // 执行权转交给另一个 generator 函数的话 yield 后面带星号，直接调用的话是没有效果的\n  yield i + 10;\n}\n\nvar gen = generator(10);\n\nconsole.log(gen.next().value); // 10\nconsole.log(gen.next().value); // 11\nconsole.log(gen.next().value); // 12\nconsole.log(gen.next(2).value); // 5\nconsole.log(gen.next().value); // 20\n// next 的返回值和迭代器的 next 类似，yield 语句的执行结果作为 value，是否还有下一个 yield 决定 done\n// next 方法可以带有参数，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果\n</code></pre><h3 id=\"Generator-函数的错误处理\"><a href=\"#Generator-函数的错误处理\" class=\"headerlink\" title=\"Generator 函数的错误处理\"></a>Generator 函数的错误处理</h3><p><code>Generator</code> 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p>\n<pre><code>function* gen(x){\n  try {\n    var y = yield x + 2;\n  } catch (e){ \n    console.log(e);\n  }\n  return y;\n}\n\nvar g = gen(1);\ng.next();\ng.throw（&#39;出错了&#39;）;\n// 出错了\n</code></pre><p>上面代码的最后一行，<code>Generator</code> 函数体外，使用指针对象的 <code>throw</code> 方法抛出的错误，可以被函数体内的 <code>try ... catch</code> 。</p>\n<h3 id=\"Generator-函数的终止\"><a href=\"#Generator-函数的终止\" class=\"headerlink\" title=\"Generator 函数的终止\"></a>Generator 函数的终止</h3><p>Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。</p>\n<pre><code>function* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nvar g = gen();\n\ng.next()        // { value: 1, done: false }\ng.return(&#39;foo&#39;) // { value: &quot;foo&quot;, done: true }\ng.next()        // { value: undefined, done: true }\n</code></pre><p>如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。</p>\n<pre><code>function* numbers () {\n  yield 1;\n  try {\n    yield 2;\n    yield 3;\n  } finally {\n    yield 4;\n    yield 5;\n  }\n  yield 6;\n}\nvar g = numbers()\ng.next() // { done: false, value: 1 }\ng.next() // { done: false, value: 2 }\ng.return(7) // { done: false, value: 4 }\ng.next() // { done: false, value: 5 }\ng.next() // { done: true, value: 7 }\n</code></pre><p>上面代码中，调用return方法后，就开始执行finally代码块，然后等到finally代码块执行完，再执行return方法。</p>\n<h3 id=\"Generator-函数的自动执行\"><a href=\"#Generator-函数的自动执行\" class=\"headerlink\" title=\"Generator 函数的自动执行\"></a>Generator 函数的自动执行</h3><p>co 库是tj写的一个让Generator函数自动执行的工具。</p>\n<pre><code>let co = require(&#39;co&#39;);\nlet p = co(gen);\n\np.then(function (){\n  console.log(&#39;ok&#39;);\n})\n</code></pre><p>co 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。</p>\n<h4 id=\"async-与-await\"><a href=\"#async-与-await\" class=\"headerlink\" title=\"async 与 await\"></a>async 与 await</h4><p>ES7 为 generator 的语法糖</p>\n","raw":"---\ntitle: Iterator and Generator\ncategories: [JavaScript, async]\ntags: [JavaScript, async]\ndate: 2016/10/13 20:46:25\n---\n\niterator 与 generator 以及后续的 async await\n\n<!-- more -->\n\n\n## iterator\n\n### 可遍历（可迭代）协议\n一个对象为了变成可遍历对象，比如说可以用 `for ... in` 结构遍历其属性值，必须实现 `@@iterator` 方法, 意思是这个对象（或者它原型链 `prototype chain` 上的某个对象）必须有一个名字是 `Symbol.iterator` 的属性。\n|属性|值|\n|---|---|\n|`[Symbol.iterator]`|返回一个对象的无参函数，被返回对象符合可遍历协议。|\n\n### 迭代器协议\n当一个对象被认为是一个迭代器时，它实现了一个 `next()` 的方法。\n该方法返回一个对象包含 `done` 和 `value` 属性，`done` 的值表示迭代器是否可以产生序列中的下一个值，`value` 为迭代器返回的任何 `JavaScript` 值。`done` 为 `true` 时可省略。\n\n---\n\n```\nlet a = {\n    q: 'q',\n    w: 'w',\n    e: 'e',\n};\nObject.defineProperty(a, length, {\n    enumerable: false,\n    value: 3\n});\n```\n现在对 a 尝试用 `for ... in` 结构遍历其属性值\n```\nfor (let v of a) {\n    console.log(v);\n}\n```\n报错：\n```\nUncaught TypeError: a[Symbol.iterator] is not a function\n```\n\n定义一个函数利用闭包实现一个将 `a` 转变为可迭代对象\n```\nfunction Iterator(obj) {\n    let i;\n\n    return ()=> {\n        return {\n            next: ()=> {\n                if (i < obj.length) {\n                    for (i in obj) {\n                        return {\n                            done: false,\n                            value: obj[i]\n                        };\n                    }\n                }\n                return {\n                    done: true\n                };\n            }\n        };\n    };\n}\n\na[Symbol.iterator] = Iterator(a);\n```\n\n## generator\n`Generator` 函数最大特点就是可以交出函数的执行权（即暂停执行）。异步操作需要暂停的地方，都用 yield 语句注明。调用 `Generator` 函数并不会执行本体，而是每次调用 `next` 方法的时候，执行到下一个碰到的 `yield` 处。\n\n\n### Generator 函数的数据交换\n\n```\nfunction* anotherGenerator(i) {\n  yield i + 1;\n  let x = yield i + 2;\n  yield x + 3;\n}\n\nfunction* generator(i){\n  yield i;\n  yield* anotherGenerator(i);\n  // 执行权转交给另一个 generator 函数的话 yield 后面带星号，直接调用的话是没有效果的\n  yield i + 10;\n}\n\nvar gen = generator(10);\n\nconsole.log(gen.next().value); // 10\nconsole.log(gen.next().value); // 11\nconsole.log(gen.next().value); // 12\nconsole.log(gen.next(2).value); // 5\nconsole.log(gen.next().value); // 20\n// next 的返回值和迭代器的 next 类似，yield 语句的执行结果作为 value，是否还有下一个 yield 决定 done\n// next 方法可以带有参数，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果\n```\n\n### Generator 函数的错误处理\n`Generator` 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。\n```\nfunction* gen(x){\n  try {\n    var y = yield x + 2;\n  } catch (e){ \n    console.log(e);\n  }\n  return y;\n}\n\nvar g = gen(1);\ng.next();\ng.throw（'出错了'）;\n// 出错了\n```\n上面代码的最后一行，`Generator` 函数体外，使用指针对象的 `throw` 方法抛出的错误，可以被函数体内的 `try ... catch` 。\n\n### Generator 函数的终止\nGenerator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。\n```\nfunction* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nvar g = gen();\n\ng.next()        // { value: 1, done: false }\ng.return('foo') // { value: \"foo\", done: true }\ng.next()        // { value: undefined, done: true }\n```\n如果Generator函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行。\n```\nfunction* numbers () {\n  yield 1;\n  try {\n    yield 2;\n    yield 3;\n  } finally {\n    yield 4;\n    yield 5;\n  }\n  yield 6;\n}\nvar g = numbers()\ng.next() // { done: false, value: 1 }\ng.next() // { done: false, value: 2 }\ng.return(7) // { done: false, value: 4 }\ng.next() // { done: false, value: 5 }\ng.next() // { done: true, value: 7 }\n```\n上面代码中，调用return方法后，就开始执行finally代码块，然后等到finally代码块执行完，再执行return方法。\n\n### Generator 函数的自动执行\nco 库是tj写的一个让Generator函数自动执行的工具。\n```\nlet co = require('co');\nlet p = co(gen);\n\np.then(function (){\n  console.log('ok');\n})\n```\nco 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。\n\n#### async 与 await\nES7 为 generator 的语法糖","photos":[],"title":"Iterator and Generator","date":"2016-10-13T12:46:25.000Z","updated":"2017-03-03T08:42:26.000Z","comments":true,"excerpt":"<p>iterator 与 generator 以及后续的 async await</p>","path":"2016/10/13/Iterator and generator/","permalink":"https://vanishingdante.github.io/gh-pages-blog-api/2016/10/13/Iterator and generator/","link":"","published":true,"categories":["JavaScript","async"],"tags":["JavaScript","async"]}